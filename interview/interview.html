<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>前端面试题汇总</title>
    <!-- Bootstrap3.3.5 CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="js/syntaxhighlighter/styles/shCore.css">
    <script type="text/javascript" src="js/syntaxhighlighter/scripts/shCore.js"></script>
    <script type="text/javascript" src="js/syntaxhighlighter/scripts/shBrushJScript.js"></script>
    <link type="text/css" rel="stylesheet" href="js/syntaxhighlighter/styles/shThemeDefault.css">
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style type="text/css">

	    body,
	    div,
	    header,
	    content {
	        margin: 0;
	        padding: 0;
	    }
	    
	    .col {
	        column-count: 2;
	        column-rule: 1px solid #e9e9e9;
    }
    </style>
</head>

<body>
    <div id="container">
        <header class="page-header">
            <h1 class="col-md-offset-1">前端面试题汇总<small>包含HTML/CSS/Javascript面试点及学习脑图</small></h1>
        </header>
        <article class="col-md-10 col-md-offset-1">
            <ul class="nav nav-tabs" id="my-tab">
                <li class="active"><a href="#htmlcss" data-toggle="tab">HTML/CSS</a></li>
                <li><a href="#javascript" data-toggle="tab">JavaScript</a>
                </li>
                <li><a href="#web" data-toggle="tab">Web前端脑图</a>
                </li>
            </ul>

            <div class="tab-content">
            	<div class="tab-pane active" id="htmlcss">
            		<h4>1.对WEB标准以及W3C的理解与认识</h4> 标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性；
                    <h4>2.xhtml和html有什么区别</h4> HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言
                    <br> 最主要的不同：
                    <br> XHTML 元素必须被正确地嵌套。
                    <br> XHTML 元素必须被关闭。
                    <br> 标签名必须用小写字母。
                    <br> XHTML 文档必须拥有根元素。
                    <br>
                    <h4>3.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?</h4> 用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档
                    <br> 严格模式：使用此类型的网页，浏览器解析将相对严格，不允许使用任何表现样式的标识和属性，比如在元素中直接使用background-color背景色属性。
                    <br> 混杂模式：浏览器对XHTML的解析较为宽松。允许使用4.01中的标签，但必须符合XHTML的语法。
                    <h4>4.行内元素有哪些?块级元素有哪些?CSS的盒模型?</h4> 块级元素：div p h1 h2 h4 h4 form ul 行内元素: a b br i span input select Css盒模型:内容，border ,margin，padding
                    <h4>5.Sass、LESS是什么？大家为什么要使用他们？</h4> 他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。

					例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。

					为什么要使用它们？

					结构清晰，便于扩展。
					可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。
					可以轻松实现多重继承。
					完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。
                    <h4>6.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?</h4> 标签选择符 类选择符 id选择符 继承不如指定 Id>class>标签选择 后者优先级高
                    <h4>7.前端页面有哪三层构成，分别是什么?作用是什么?</h4> 结构层 Html 表示层 CSS 行为层 js
                    <h4>8.css的基本语句构成是?</h4> 选择器{属性1:值1;属性2:值2;……}
                    <h4>9.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?经常遇到的浏览器的兼容性有哪些?怎么会出现?解决方法是什么?</h4> IE6、7、8、FF、Opear、Safari、Chrome、Maxthon
                    <br> Trident：Windows 下的 IE 浏览器使用的内核代号。除 IE 外，众多的 IE Shell（如 Maxthon ）都使用这个内核。
                    <br> Gecko：Mozilla Firefox 浏览器使用的内核代号。
                    <br> Presto：Opera 浏览器使用的内核代号，这是目前公认网页浏览速度最快的浏览器内核。
                    <br> KHTML/WebCore： Konqueror/Safari 浏览器使用的内核代号。
                    <br> 经常遇到的浏览器兼容问题：
                    <br> 1.在有的浏览器中，默认字体大小为12px,所以在设字体大小的时候，最小设为12px，如果在做的过程中，发现字体小于12，可直接作为图片使用
                    <br> 2.a标签对里不能嵌套a标签对
                    <br> 3.若给a标签内的内容样式加上样式，需要设置display:block;（在IE中如果设置宽高会自动变成块，在FF中则不会），但如果设置了float属性，就不需要设置display:block。
                    <br> 4.ul，ol在FF默认情况下，有list-style-type样式和padding值，dl在IE和FF默认情况下，有padding值，所以应该事先声明ul,li,ol,dl,dd,dd{margin:0;padding:0}。
                    <br> 5.作为外部 wrapper 的 div 不要定死高度, 最好还加上 overflow: hidden.以达到高度自适应
                    <br> 6.关于手形光标. cursor: pointer. 而hand 只适用于 IE.
                    <br> 7.css布局中的居中问题:在父级元素定义TEXT-ALIGN: center;这个的意思就是在父级元素内的内容居中；对于IE这样设定就已经可以了。但在mozilla中不能居中。解决办法就是在子元素定义时候设定时再加上“margin-right: auto;margin-left: auto;”需要说明的是，如果你想用这个方法使整个页面要居中，建议不要套在一个DIV里，你可以依次拆出多个div，只要在每个拆出的div里定义margin-right: auto;margin-left: auto; 就可以了。
                    <br> 8.浮动ie产生的双倍距离
                    <br> #box{ float:left; width:100px; margin:0 0 0 100px; //这种情况之下IE会产生200px的距离，这时需要设置display:inline; //使浮动忽略}
                    <h4>10.写出几种IE6 BUG的解决方法</h4> 1.双边距BUG float引起的 使用display
                    <br> 2.3像素问题 使用float引起的 使用dislpay:inline -3px
                    <br> 3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active
                    <br> 4.Ie z-index问题 给父级添加position:relative
                    <br> 5.Png 透明 使用js代码 改
                    <br> 6.Min-height 最小高度 ！Important 解决
                    <br> 7.select 在ie6下遮盖 使用iframe嵌套
                    <br> 8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）
                    <br>
                    <h4>11.标签上title与alt属性的区别是什么?</h4> Alt 当图片不显示是 用文字代表。
                    <br> Title 为该属性提供信息
                    <br>
                    <h4>12.描述css reset的作用和用途。</h4> Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一
                    <h4>13.解释css sprites，如何使用。</h4> Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量
                    <h4>14.浏览器标准模式和怪异模式之间的区别是什么?</h4> 盒子模型 渲染模式的不同 使用 window.top.document.compatMode 可显示为什么模式
                    <h4>15.你如何对网站的文件和资源进行优化?期待的解决方案包括：</h4> 文件合并 文件最小化/文件压缩 使用CDN托管 缓存的使用
                    <h4>16.什么是语义化的HTML?</h4> 直观的认识标签 对于搜索引擎的抓取有好处
                    <h4>17.清除浮动的几种方式，各自的优缺点</h4> 1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签） 2.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE） 3.是用afert伪元素清除浮动(用于非IE浏览器)
                    <h4>18.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?</h4> CSS选择符: 类选择器 、 标签名选择器、 ID选择器 、 后代选择器（派生选择器）、 群组选择器
                    <br> 可以继承： 类选择器 、 标签名选择器、 后代选择器（派生选择器）、群组选择器
                    <br> 优先级算法：
                    <br> 标签内直接定义：1000
                    <br> ID选择器：100
                    <br> 类选择器 ：10
                    <br> 标签名选择器：1
                    <br> 内联和important中，important优先级高
                    <br>
                    <h4>19.如何居中一个浮动元素?</h4> 对其设置margin:x auto;
                    <h4>20.有没有关注HTML5和CSS3?如有请简单说一些您对它们的了解情况！</h4> 有，HTML5的是目前正在为未来的HTML标准的主要修订的发展。其前任一样，4.01和XHTML 1.1的HTML，HTML5的是一个结构和提交万维网内容的标准。新标准结合了诸如视频播放，拖动和放下以前曾在第三方浏览器插件依赖例如Adobe Flash，微软的Silverlight的功能，和谷歌齿轮。
                    <h4>21:如果让你来制作一个访问量很高的大型网站，你会如何来管理所有CSS文件、JS与图片?</h4> 把所有的CSS文件都放入一个样式表中,通过把所有的脚本放到一个文件中来减少HTTP请求的方法。js文件也采用同样的方法。把所有的背景图像都放到一个图片文件中，然后通过CSS的background-image和background-position属性来显示图片的不同部分。
                    <h4>22.你对前端界面工程师这个职位是怎么样理解的?它的前景会怎么样?</h4> 前端界面工程师：1. 与交互设计师、视觉设计师协作，根据设计图完成页面制作。 2. 维护及优化网站前端性能。 前景： 长期以来，国内前端开发在整个软件开发行业内占得比重较小，发展较晚。网站也多倾向于赢利最大化而轻视用户体验。前后端比例悬殊大。近几年来，随着 以用户为中心 的思想普及发展。前端开发呈现出强劲的发展态势，前端开发人员在项目中的重要性日益突出。前端开发人员呈现出严重的人员短缺现象。
            	</div>
            	<div class="tab-pane" id="javascript">
            		<h4>1.实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h4>
            		答案：第一种方法：
            		<pre class="brush:js">
					function clone(Obj) {   
					        var buf;   
					        if (Obj instanceof Array) {   
					            buf = [];                    //创建一个空的数组 
					            var i = Obj.length;   
					            while (i--) {   
					                buf[i] = clone(Obj[i]);   
					            }   
					            return buf;    
					        }else if (Obj instanceof Object){   
					            buf = {};                   //创建一个空对象 
					            for (var k in Obj) {           //为这个对象添加新的属性 
					                buf[k] = clone(Obj[k]);   
					            }   
					            return buf;   
					        }else{                         //普通变量直接赋值
					            return Obj;   
					        }   
					}</pre>
            		第二种方法：
            		<pre class="brush:js">
					Object.prototype.clone = function(){
					        var o = this.constructor === Array ? [] : {};
					        for(var e in this){
					                o[e] = typeof this[e] === "object" ? this[e].clone() : this[e];
					        }
					        return o;
					}
            		</pre>
            		<h4>2.下面这个ul，如何点击每一列的时候alert其index?（闭包）</h4>
            		<pre class="brush:js">
					<ul id='test'>
					<li>这是第一条</li>
					<li>这是第二条</li>
					<li>这是第三条</li>
					</ul>
            		</pre>
            		答案：
            		<pre class="brush:js">
					// 方法一：
					var lis=document.getElementById('2223').getElementsByTagName('li');
					for(var i=0;i<3;i++)
					{
					    lis[i].index=i;
					    lis[i].onclick=function(){
					        alert(this.index);
					    };
					}
					 
					//方法二：
					var lis=document.getElementById('2223').getElementsByTagName('li');
					for(var i=0;i<3;i++)
					{
					    lis[i].index=i;
					    lis[i].onclick=(function(a){
					        return function() {
					            alert(a);
					        }
					    })(i);
					}
            		</pre>
            		<h4>3.在Javascript中什么是伪数组？如何将伪数组转化为标准数组？</h4>
            		答案：

					伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。
					            		<h4>4.对作用域上下文和this的理解，看下列代码：问两处console输出什么？为什么？</h4>
					            		<pre class="brush:js">
					var User = {
					  count: 1,
					 
					  getCount: function() {
					    return this.count;
					  }
					};
					 
					console.log(User.getCount());  // what?
					 
					var func = User.getCount;
					console.log(func());  // what?
            		</pre>
            		答案是1和undefined。

					func是在winodw的上下文中被执行的，所以会访问不到count属性。

					继续追问，那么如何确保Uesr总是能访问到func的上下文，即正确返回1。正确的方法是使用Function.prototype.bind。兼容各个浏览器完整代码如下：
					<pre class="brush:js">
					Function.prototype.bind = Function.prototype.bind || function(context){
					   var self = this;
					 
					   return function(){
					      return self.apply(context, arguments);
					   };
					}
					 
					var func = User.getCount.bind(User);
					console.log(func());
					</pre>
            		<h4>5.原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现Jq的ready方法？</h4>
            		答案：window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。
            		<pre class="brush:js">
            		function ready(fn){
					    if(document.addEventListener) {        //标准浏览器
					        document.addEventListener('DOMContentLoaded', function() {
					            //注销事件, 避免反复触发
					            document.removeEventListener('DOMContentLoaded',arguments.callee, false);
					            fn();            //执行函数
					        }, false);
					    }else if(document.attachEvent) {        //IE
					        document.attachEvent('onreadystatechange', function() {
					            if(document.readyState == 'complete') {
					                document.detachEvent('onreadystatechange', arguments.callee);
					                fn();        //函数执行
					            }
					        });
					    }
					};
            		</pre>
            		<h4>6.（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</h4>
            		回答出概念即可，下面是几个要点

					1.给需要拖拽的节点绑定mousedown, mousemove, mouseup事件
					2.mousedown事件触发后，开始拖拽
					3.mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置
					4.mouseup时，拖拽结束
					5.需要注意浏览器边界的情况
            		<h4>7.说出以下函数的作用是？空白区域应该填写什么？</h4>
            		<pre class="brush:js">
					//define 
					(function(window){
					    function fn(str){
					        this.str=str;
					    }
					 
					    fn.prototype.format = function(){
					        var arg = ______;
					        return this.str.replace(_____,function(a,b){
					             return arg[b]||"";
					      });
					    }
					    window.fn = fn;
					})(window);
					 
					//use
					(function(){
					    var t = new fn('<p><a href="{0}">{1}</a><span>{2}</span></p>');
					    console.log(t.format('http://www.alibaba.com','Alibaba','Welcome'));
					})();
            		</pre>
            		答案：访函数的作用是使用format函数将函数的参数替换掉{0}这样的内容，返回一个格式化后的结果：

					第一个空是：arguments

					第二个空是：/\{(\d+)\}/ig
            		<h4>8.JavaScript的数据类型都有什么？</h4>
            		答案:基本数据类型：String,boolean,Number,Undefined, Null

					引用数据类型：Object(Array,Date,RegExp,Function)

					那么问题来了，如何判断某变量是否为数组数据类型？

					方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效
					方法二.obj instanceof Array 在某些IE版本中不正确
					方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下：
					<pre class="brush:js">
					if(typeof Array.isArray==="undefined")
					{
					  Array.isArray = function(arg){
					        return Object.prototype.toString.call(arg)==="[object Array]"
					    };  
					}</pre>
            		<h4>9.希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</h4>
            		<pre class="brush:js">
            			var domList = document.getElementsByTagName(‘input’)
						var checkBoxList = [];
						var len = domList.length;　　//缓存到局部变量
						while (len--) {　　//使用while的效率会比for循环更高
						　　if (domList[len].type == ‘checkbox’) {
						    　　checkBoxList.push(domList[len]);
						　　}
						}
            		</pre>
            		<h4>10.设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)</h4>
            		<pre class="brush:js">
					var dom = document.getElementById(“ID”);
					dom.innerHTML = “xxxx”
					dom.style.color = “#000”
            		</pre>
            		<h4>11.当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？</h4>
            		直接在DOM里绑定事件：<div onclick=”test()”></div>
					在JS里通过onclick绑定：xxx.onclick = test
					通过事件添加进行绑定：addEventListener(xxx, ‘click’, test)
					那么问题来了，Javascript的事件流模型都有什么？

					“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播
					“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的
					“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡
            		<h4>12.什么是Ajax和JSON，它们的优缺点。</h4>
            		Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互。

					优点：

					　可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量
					　避免用户不断刷新或者跳转页面，提高用户体验
					缺点：

					　对搜索引擎不友好（
					　要实现ajax下的前后退功能成本较大
					　可能造成请求数的增加
					　跨域问题限制
					JSON是一种轻量级的数据交换格式，ECMA的一个子集

					优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）
            		<h4>13.看下列代码,输出什么？解释原因。</h4>
            		<pre class="brush:js">
            			var undefined;
						undefined == null; // true
						1 == true;   // true
						2 == true;   // false
						0 == false;  // true
						0 == '';     // true
						NaN == NaN;  // false
						[] == false; // true
						[] == ![];   // true
            		</pre>
            		undefined与null相等，但不恒等（===）
					一个是number一个是string时，会尝试将string转换为number
					尝试将boolean转换为number，0或1
					尝试将Object转换成number或string，取决于另外一个对比量的类型
					所以，对于0、空字符串的判断，建议使用 “===” 。“===”会先判断两边的值类型，类型不匹配时为false。
					那么问题来了，看下面的代码，输出什么，foo的值为什么？
					<pre class="brush:js">
					var foo = "11"+2-"1";
					console.log(foo);
					console.log(typeof foo);
            		</pre>
            		执行完后foo的值为111，foo的类型为String。
            		<h4>14.输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26</h4>
            		<pre class="brush:js">
            			var d = new Date();
						// 获取年，getFullYear()返回4位的数字
						var year = d.getFullYear();
						// 获取月，月份比较特殊，0是1月，11是12月
						var month = d.getMonth() + 1;
						// 变成两位
						month = month < 10 ? '0' + month : month;
						// 获取日
						var day = d.getDate();
						day = day < 10 ? '0' + day : day;
						alert(year + '-' + month + '-' + day);
            		</pre>
            		<h4>15把两个数组合并，并删除第二个元素。</h4>
            		<pre class="brush:js">
					var array1 = ['a','b','c'];
					var bArray = ['d','e','f'];
					var cArray = array1.concat(bArray);
					cArray.splice(1,1);
            		</pre>
            		<h4>16.用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。</h4>
            		<pre class="brush:js">
            		var iArray = []; 
					funtion getRandom(istart, iend){
						    var iChoice = istart - iend +1;
						    return Math.floor(Math.random() * iChoice + istart;
					}
					for(var i=0; i<10; i++){
						    iArray.push(getRandom(10,100));
					}
					iArray.sort();
            		</pre>
            		<h4>17.看下面代码，给出输出结果。</h4>
            		<pre class="brush:js">
            		for(var i=1;i<=3;i++){
					  setTimeout(function(){
					      console.log(i);    
					  },0);  
					};
            		</pre>
            		答案：4 4 4
            		<h4>18：Javascript中callee和caller的作用？</h4>
            		答案：

					caller是返回一个对函数的引用，该函数调用了当前函数；

					callee是返回正在被执行的function函数，也就是所指定的function对象的正文。

					那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成）
            		<pre class="brush:js">
            		var result=[];
					function fn(n){  //典型的斐波那契数列
					   if(n==1){
					        return 1;
					   }else if(n==2){
					           return 1;
					   }else{
					        if(result[n]){
					                return result[n];
					        }else{
					                //argument.callee()表示fn()
					                result[n]=arguments.callee(n-1)+arguments.callee(n-2);
					                return result[n];
					        }
					   }
					}
            		</pre>
            	</div>

            	<div class="tab-pane" id="web">
					<img src="img/20157392134588.jpg" width="100%">
            	</div>
            </div>
            
        </article>
    </div>
    <script src="js/jquery-3.1.1.min.js "></script>
    <script src="js/bootstrap.min.js "></script>
</body>

</html>
